{"name":"Auto-DevOps","content":"# This file is a template, and might need editing before it works on your project.\n# Auto DevOps\n# This CI/CD configuration provides a standard pipeline for\n# * building a Docker image (using a buildpack if necessary),\n# * storing the image in the container registry,\n# * running tests from a buildpack,\n# * running code quality analysis,\n# * creating a review app for each topic branch,\n# * and continuous deployment to production\n#\n# Test jobs may be disabled by setting environment variables:\n# * test: TEST_DISABLED\n# * code_quality: CODE_QUALITY_DISABLED\n# * license_management: LICENSE_MANAGEMENT_DISABLED\n# * performance: PERFORMANCE_DISABLED\n# * sast: SAST_DISABLED\n# * dependency_scanning: DEPENDENCY_SCANNING_DISABLED\n# * container_scanning: CONTAINER_SCANNING_DISABLED\n# * dast: DAST_DISABLED\n# * review: REVIEW_DISABLED\n# * stop_review: REVIEW_DISABLED\n#\n# In order to deploy, you must have a Kubernetes cluster configured either\n# via a project integration, or via group/project variables.\n# KUBE_INGRESS_BASE_DOMAIN must also be set on the cluster settings,\n# as a variable at the group or project level, or manually added below.\n#\n# Continuous deployment to production is enabled by default.\n# If you want to deploy to staging first, set STAGING_ENABLED environment variable.\n# If you want to enable incremental rollout, either manual or time based,\n# set INCREMENTAL_ROLLOUT_MODE environment variable to \"manual\" or \"timed\".\n# If you want to use canary deployments, set CANARY_ENABLED environment variable.\n#\n# If Auto DevOps fails to detect the proper buildpack, or if you want to\n# specify a custom buildpack, set a project variable `BUILDPACK_URL` to the\n# repository URL of the buildpack.\n# e.g. BUILDPACK_URL=https://github.com/heroku/heroku-buildpack-ruby.git#v142\n# If you need multiple buildpacks, add a file to your project called\n# `.buildpacks` that contains the URLs, one on each line, in order.\n# Note: Auto CI does not work with multiple buildpacks yet\n\nimage: alpine:latest\n\nvariables:\n  # KUBE_INGRESS_BASE_DOMAIN is the application deployment domain and should be set as a variable at the group or project level.\n  # KUBE_INGRESS_BASE_DOMAIN: domain.example.com\n\n  POSTGRES_USER: user\n  POSTGRES_PASSWORD: testing-password\n  POSTGRES_ENABLED: \"true\"\n  POSTGRES_DB: $CI_ENVIRONMENT_SLUG\n  POSTGRES_VERSION: 9.6.2\n\n  KUBERNETES_VERSION: 1.11.7\n  HELM_VERSION: 2.12.3\n\n  DOCKER_DRIVER: overlay2\n\n  ROLLOUT_RESOURCE_TYPE: deployment\n\nstages:\n  - build\n  - test\n  - review\n  - dast\n  - staging\n  - canary\n  - production\n  - incremental rollout 10%\n  - incremental rollout 25%\n  - incremental rollout 50%\n  - incremental rollout 100%\n  - performance\n  - cleanup\n\nbuild:\n  stage: build\n  image: \"registry.gitlab.com/gitlab-org/cluster-integration/auto-build-image/master:stable\"\n  services:\n    - docker:stable-dind\n  script:\n    - /build/build.sh\n  only:\n    - branches\n    - tags\n\ntest:\n  services:\n    - postgres:latest\n  variables:\n    POSTGRES_DB: test\n  stage: test\n  image: gliderlabs/herokuish:latest\n  script:\n    - setup_test_db\n    - cp -R . /tmp/app\n    - /bin/herokuish buildpack test\n  only:\n    - branches\n    - tags\n  except:\n    variables:\n      - $TEST_DISABLED\n\ncode_quality:\n  stage: test\n  image: docker:stable\n  allow_failure: true\n  services:\n    - docker:stable-dind\n  script:\n    - setup_docker\n    - code_quality\n  artifacts:\n    paths: [gl-code-quality-report.json]\n  only:\n    - branches\n    - tags\n  except:\n    variables:\n      - $CODE_QUALITY_DISABLED\n\nlicense_management:\n  stage: test\n  image:\n    name: \"registry.gitlab.com/gitlab-org/security-products/license-management:$CI_SERVER_VERSION_MAJOR-$CI_SERVER_VERSION_MINOR-stable\"\n    entrypoint: [\"\"]\n  allow_failure: true\n  script:\n    - license_management\n  artifacts:\n    paths: [gl-license-management-report.json]\n  only:\n    refs:\n      - branches\n      - tags\n    variables:\n      - $GITLAB_FEATURES =~ /\\blicense_management\\b/\n  except:\n    variables:\n      - $LICENSE_MANAGEMENT_DISABLED\n\nperformance:\n  stage: performance\n  image: docker:stable\n  allow_failure: true\n  services:\n    - docker:stable-dind\n  script:\n    - setup_docker\n    - performance\n  artifacts:\n    paths:\n    - performance.json\n    - sitespeed-results/\n  only:\n    refs:\n      - branches\n      - tags\n    kubernetes: active\n  except:\n    variables:\n      - $PERFORMANCE_DISABLED\n\nsast:\n  stage: test\n  image: docker:stable\n  allow_failure: true\n  services:\n    - docker:stable-dind\n  script:\n    - setup_docker\n    - sast\n  artifacts:\n    reports:\n      sast: gl-sast-report.json\n  only:\n    refs:\n      - branches\n      - tags\n    variables:\n      - $GITLAB_FEATURES =~ /\\bsast\\b/\n  except:\n    variables:\n      - $SAST_DISABLED\n\ndependency_scanning:\n  stage: test\n  image: docker:stable\n  allow_failure: true\n  services:\n    - docker:stable-dind\n  script:\n    - setup_docker\n    - dependency_scanning\n  artifacts:\n    reports:\n      dependency_scanning: gl-dependency-scanning-report.json\n  only:\n    refs:\n      - branches\n      - tags\n    variables:\n      - $GITLAB_FEATURES =~ /\\bdependency_scanning\\b/\n  except:\n    variables:\n      - $DEPENDENCY_SCANNING_DISABLED\n\ncontainer_scanning:\n  stage: test\n  image: docker:stable\n  allow_failure: true\n  services:\n    - docker:stable-dind\n  script:\n    - setup_docker\n    - container_scanning\n  artifacts:\n    paths: [gl-container-scanning-report.json]\n  only:\n    refs:\n      - branches\n      - tags\n    variables:\n      - $GITLAB_FEATURES =~ /\\bcontainer_scanning\\b/\n  except:\n    variables:\n      - $CONTAINER_SCANNING_DISABLED\n\ndast:\n  stage: dast\n  allow_failure: true\n  image: registry.gitlab.com/gitlab-org/security-products/zaproxy\n  variables:\n    POSTGRES_DB: \"false\"\n  script:\n    - dast\n  artifacts:\n    paths: [gl-dast-report.json]\n  only:\n    refs:\n      - branches\n      - tags\n    kubernetes: active\n    variables:\n      - $GITLAB_FEATURES =~ /\\bdast\\b/\n  except:\n    refs:\n      - master\n    variables:\n      - $DAST_DISABLED\n\nreview:\n  stage: review\n  script:\n    - check_kube_domain\n    - install_dependencies\n    - download_chart\n    - ensure_namespace\n    - initialize_tiller\n    - create_secret\n    - deploy\n    - persist_environment_url\n  environment:\n    name: review/$CI_COMMIT_REF_NAME\n    url: http://$CI_PROJECT_PATH_SLUG-$CI_ENVIRONMENT_SLUG.$KUBE_INGRESS_BASE_DOMAIN\n    on_stop: stop_review\n  artifacts:\n    paths: [environment_url.txt]\n  only:\n    refs:\n      - branches\n      - tags\n    kubernetes: active\n  except:\n    refs:\n      - master\n    variables:\n      - $REVIEW_DISABLED\n\nstop_review:\n  stage: cleanup\n  variables:\n    GIT_STRATEGY: none\n  script:\n    - install_dependencies\n    - initialize_tiller\n    - delete\n  environment:\n    name: review/$CI_COMMIT_REF_NAME\n    action: stop\n  when: manual\n  allow_failure: true\n  only:\n    refs:\n      - branches\n      - tags\n    kubernetes: active\n  except:\n    refs:\n      - master\n    variables:\n      - $REVIEW_DISABLED\n\n# Staging deploys are disabled by default since\n# continuous deployment to production is enabled by default\n# If you prefer to automatically deploy to staging and\n# only manually promote to production, enable this job by setting\n# STAGING_ENABLED.\n\nstaging:\n  stage: staging\n  script:\n    - check_kube_domain\n    - install_dependencies\n    - download_chart\n    - ensure_namespace\n    - initialize_tiller\n    - create_secret\n    - deploy\n  environment:\n    name: staging\n    url: http://$CI_PROJECT_PATH_SLUG-staging.$KUBE_INGRESS_BASE_DOMAIN\n  only:\n    refs:\n      - master\n    kubernetes: active\n    variables:\n      - $STAGING_ENABLED\n\n# Canaries are also disabled by default, but if you want them,\n# and know what the downsides are, you can enable this by setting\n# CANARY_ENABLED.\n\ncanary:\n  stage: canary\n  script:\n    - check_kube_domain\n    - install_dependencies\n    - download_chart\n    - ensure_namespace\n    - initialize_tiller\n    - create_secret\n    - deploy canary\n  environment:\n    name: production\n    url: http://$CI_PROJECT_PATH_SLUG.$KUBE_INGRESS_BASE_DOMAIN\n  when: manual\n  only:\n    refs:\n      - master\n    kubernetes: active\n    variables:\n      - $CANARY_ENABLED\n\n.production: \u0026production_template\n  stage: production\n  script:\n    - check_kube_domain\n    - install_dependencies\n    - download_chart\n    - ensure_namespace\n    - initialize_tiller\n    - create_secret\n    - deploy\n    - delete canary\n    - delete rollout\n    - persist_environment_url\n  environment:\n    name: production\n    url: http://$CI_PROJECT_PATH_SLUG.$KUBE_INGRESS_BASE_DOMAIN\n  artifacts:\n    paths: [environment_url.txt]\n\nproduction:\n  \u003c\u003c: *production_template\n  only:\n    refs:\n      - master\n    kubernetes: active\n  except:\n    variables:\n      - $STAGING_ENABLED\n      - $CANARY_ENABLED\n      - $INCREMENTAL_ROLLOUT_ENABLED\n      - $INCREMENTAL_ROLLOUT_MODE\n\nproduction_manual:\n  \u003c\u003c: *production_template\n  when: manual\n  allow_failure: false\n  only:\n    refs:\n      - master\n    kubernetes: active\n    variables:\n      - $STAGING_ENABLED\n      - $CANARY_ENABLED\n  except:\n    variables:\n      - $INCREMENTAL_ROLLOUT_ENABLED\n      - $INCREMENTAL_ROLLOUT_MODE\n\n# This job implements incremental rollout on for every push to `master`.\n\n.rollout: \u0026rollout_template\n  script:\n    - check_kube_domain\n    - install_dependencies\n    - download_chart\n    - ensure_namespace\n    - initialize_tiller\n    - create_secret\n    - deploy rollout $ROLLOUT_PERCENTAGE\n    - scale stable $((100-ROLLOUT_PERCENTAGE))\n    - delete canary\n    - persist_environment_url\n  environment:\n    name: production\n    url: http://$CI_PROJECT_PATH_SLUG.$KUBE_INGRESS_BASE_DOMAIN\n  artifacts:\n    paths: [environment_url.txt]\n\n.manual_rollout_template: \u0026manual_rollout_template\n  \u003c\u003c: *rollout_template\n  stage: production\n  when: manual\n  # This selectors are backward compatible mode with $INCREMENTAL_ROLLOUT_ENABLED (before 11.4)\n  only:\n    refs:\n      - master\n    kubernetes: active\n    variables:\n      - $INCREMENTAL_ROLLOUT_MODE == \"manual\"\n      - $INCREMENTAL_ROLLOUT_ENABLED\n  except:\n    variables:\n      - $INCREMENTAL_ROLLOUT_MODE == \"timed\"\n\n.timed_rollout_template: \u0026timed_rollout_template\n  \u003c\u003c: *rollout_template\n  when: delayed\n  start_in: 5 minutes\n  only:\n    refs:\n      - master\n    kubernetes: active\n    variables:\n      - $INCREMENTAL_ROLLOUT_MODE == \"timed\"\n\ntimed rollout 10%:\n  \u003c\u003c: *timed_rollout_template\n  stage: incremental rollout 10%\n  variables:\n    ROLLOUT_PERCENTAGE: 10\n\ntimed rollout 25%:\n  \u003c\u003c: *timed_rollout_template\n  stage: incremental rollout 25%\n  variables:\n    ROLLOUT_PERCENTAGE: 25\n\ntimed rollout 50%:\n  \u003c\u003c: *timed_rollout_template\n  stage: incremental rollout 50%\n  variables:\n    ROLLOUT_PERCENTAGE: 50\n\ntimed rollout 100%:\n  \u003c\u003c: *timed_rollout_template\n  \u003c\u003c: *production_template\n  stage: incremental rollout 100%\n  variables:\n    ROLLOUT_PERCENTAGE: 100\n\nrollout 10%:\n  \u003c\u003c: *manual_rollout_template\n  variables:\n    ROLLOUT_PERCENTAGE: 10\n\nrollout 25%:\n  \u003c\u003c: *manual_rollout_template\n  variables:\n    ROLLOUT_PERCENTAGE: 25\n\nrollout 50%:\n  \u003c\u003c: *manual_rollout_template\n  variables:\n    ROLLOUT_PERCENTAGE: 50\n\nrollout 100%:\n  \u003c\u003c: *manual_rollout_template\n  \u003c\u003c: *production_template\n  allow_failure: false\n\n# ---------------------------------------------------------------------------\n\n.auto_devops: \u0026auto_devops |\n  # Auto DevOps variables and functions\n  [[ \"$TRACE\" ]] \u0026\u0026 set -x\n  auto_database_url=postgres://${POSTGRES_USER}:${POSTGRES_PASSWORD}@${CI_ENVIRONMENT_SLUG}-postgres:5432/${POSTGRES_DB}\n  export DATABASE_URL=${DATABASE_URL-$auto_database_url}\n  if [[ -z \"$CI_COMMIT_TAG\" ]]; then\n    export CI_APPLICATION_REPOSITORY=$CI_REGISTRY_IMAGE/$CI_COMMIT_REF_SLUG\n    export CI_APPLICATION_TAG=$CI_COMMIT_SHA\n  else\n    export CI_APPLICATION_REPOSITORY=$CI_REGISTRY_IMAGE\n    export CI_APPLICATION_TAG=$CI_COMMIT_TAG\n  fi\n  export TILLER_NAMESPACE=$KUBE_NAMESPACE\n  # Extract \"MAJOR.MINOR\" from CI_SERVER_VERSION and generate \"MAJOR-MINOR-stable\" for Security Products\n  export SP_VERSION=$(echo \"$CI_SERVER_VERSION\" | sed 's/^\\([0-9]*\\)\\.\\([0-9]*\\).*/\\1-\\2-stable/')\n\n  function registry_login() {\n    if [[ -n \"$CI_REGISTRY_USER\" ]]; then\n      echo \"Logging to GitLab Container Registry with CI credentials...\"\n      docker login -u \"$CI_REGISTRY_USER\" -p \"$CI_REGISTRY_PASSWORD\" \"$CI_REGISTRY\"\n      echo \"\"\n    fi\n  }\n\n  function container_scanning() {\n    registry_login\n\n    docker run -d --name db arminc/clair-db:latest\n    docker run -p 6060:6060 --link db:postgres -d --name clair --restart on-failure arminc/clair-local-scan:v2.0.1\n    apk add -U wget ca-certificates\n    docker pull ${CI_APPLICATION_REPOSITORY}:${CI_APPLICATION_TAG}\n    wget https://github.com/arminc/clair-scanner/releases/download/v8/clair-scanner_linux_amd64\n    mv clair-scanner_linux_amd64 clair-scanner\n    chmod +x clair-scanner\n    touch clair-whitelist.yml\n    retries=0\n    echo \"Waiting for clair daemon to start\"\n    while( ! wget -T 10 -q -O /dev/null http://docker:6060/v1/namespaces ) ; do sleep 1 ; echo -n \".\" ; if [ $retries -eq 10 ] ; then echo \" Timeout, aborting.\" ; exit 1 ; fi ; retries=$(($retries+1)) ; done\n    ./clair-scanner -c http://docker:6060 --ip $(hostname -i) -r gl-container-scanning-report.json -l clair.log -w clair-whitelist.yml ${CI_APPLICATION_REPOSITORY}:${CI_APPLICATION_TAG} || true\n  }\n\n  function code_quality() {\n    docker run --env SOURCE_CODE=\"$PWD\" \\\n               --volume \"$PWD\":/code \\\n               --volume /var/run/docker.sock:/var/run/docker.sock \\\n               \"registry.gitlab.com/gitlab-org/security-products/codequality:$SP_VERSION\" /code\n  }\n\n  function license_management() {\n    /run.sh analyze .\n  }\n\n  function sast() {\n    case \"$CI_SERVER_VERSION\" in\n      *-ee)\n\n        # Deprecation notice for CONFIDENCE_LEVEL variable\n        if [ -z \"$SAST_CONFIDENCE_LEVEL\" -a \"$CONFIDENCE_LEVEL\" ]; then\n          SAST_CONFIDENCE_LEVEL=\"$CONFIDENCE_LEVEL\"\n          echo \"WARNING: CONFIDENCE_LEVEL is deprecated and MUST be replaced with SAST_CONFIDENCE_LEVEL\"\n        fi\n\n        docker run --env SAST_CONFIDENCE_LEVEL=\"${SAST_CONFIDENCE_LEVEL:-3}\" \\\n                   --volume \"$PWD:/code\" \\\n                   --volume /var/run/docker.sock:/var/run/docker.sock \\\n                   \"registry.gitlab.com/gitlab-org/security-products/sast:$SP_VERSION\" /app/bin/run /code\n        ;;\n      *)\n        echo \"GitLab EE is required\"\n        ;;\n    esac\n  }\n\n  function dependency_scanning() {\n    case \"$CI_SERVER_VERSION\" in\n      *-ee)\n        docker run --env DEP_SCAN_DISABLE_REMOTE_CHECKS=\"${DEP_SCAN_DISABLE_REMOTE_CHECKS:-false}\" \\\n                   --volume \"$PWD:/code\" \\\n                   --volume /var/run/docker.sock:/var/run/docker.sock \\\n                   \"registry.gitlab.com/gitlab-org/security-products/dependency-scanning:$SP_VERSION\" /code\n        ;;\n      *)\n        echo \"GitLab EE is required\"\n        ;;\n    esac\n  }\n\n  function get_replicas() {\n    track=\"${1:-stable}\"\n    percentage=\"${2:-100}\"\n\n    env_track=$( echo $track | tr -s  '[:lower:]'  '[:upper:]' )\n    env_slug=$( echo ${CI_ENVIRONMENT_SLUG//-/_} | tr -s  '[:lower:]'  '[:upper:]' )\n\n    if [[ \"$track\" == \"stable\" ]] || [[ \"$track\" == \"rollout\" ]]; then\n      # for stable track get number of replicas from `PRODUCTION_REPLICAS`\n      eval new_replicas=\\$${env_slug}_REPLICAS\n      if [[ -z \"$new_replicas\" ]]; then\n        new_replicas=$REPLICAS\n      fi\n    else\n      # for all tracks get number of replicas from `CANARY_PRODUCTION_REPLICAS`\n      eval new_replicas=\\$${env_track}_${env_slug}_REPLICAS\n      if [[ -z \"$new_replicas\" ]]; then\n        eval new_replicas=\\${env_track}_REPLICAS\n      fi\n    fi\n\n    replicas=\"${new_replicas:-1}\"\n    replicas=\"$(($replicas * $percentage / 100))\"\n\n    # always return at least one replicas\n    if [[ $replicas -gt 0 ]]; then\n      echo \"$replicas\"\n    else\n      echo 1\n    fi\n  }\n\n  # Extracts variables prefixed with K8S_SECRET_\n  # and creates a Kubernetes secret.\n  #\n  # e.g. If we have the following environment variables:\n  #   K8S_SECRET_A=value1\n  #   K8S_SECRET_B=multi\\ word\\ value\n  #\n  # Then we will create a secret with the following key-value pairs:\n  #   data:\n  #     A: dmFsdWUxCg==\n  #     B: bXVsdGkgd29yZCB2YWx1ZQo=\n  function create_application_secret() {\n    track=\"${1-stable}\"\n    export APPLICATION_SECRET_NAME=$(application_secret_name \"$track\")\n\n    env | sed -n \"s/^K8S_SECRET_\\(.*\\)$/\\1/p\" \u003e k8s_prefixed_variables\n\n    kubectl create secret \\\n      -n \"$KUBE_NAMESPACE\" generic \"$APPLICATION_SECRET_NAME\" \\\n      --from-env-file k8s_prefixed_variables -o yaml --dry-run |\n      kubectl replace -n \"$KUBE_NAMESPACE\" --force -f -\n\n    export APPLICATION_SECRET_CHECKSUM=$(cat k8s_prefixed_variables | sha256sum | cut -d ' ' -f 1)\n\n    rm k8s_prefixed_variables\n  }\n\n  function deploy_name() {\n    name=\"$CI_ENVIRONMENT_SLUG\"\n    track=\"${1-stable}\"\n\n    if [[ \"$track\" != \"stable\" ]]; then\n      name=\"$name-$track\"\n    fi\n\n    echo $name\n  }\n\n  function application_secret_name() {\n    track=\"${1-stable}\"\n    name=$(deploy_name \"$track\")\n\n    echo \"${name}-secret\"\n  }\n\n  function deploy() {\n    track=\"${1-stable}\"\n    percentage=\"${2:-100}\"\n    name=$(deploy_name \"$track\")\n\n    replicas=\"1\"\n    service_enabled=\"true\"\n    postgres_enabled=\"$POSTGRES_ENABLED\"\n\n    # if track is different than stable,\n    # re-use all attached resources\n    if [[ \"$track\" != \"stable\" ]]; then\n      service_enabled=\"false\"\n      postgres_enabled=\"false\"\n    fi\n\n    replicas=$(get_replicas \"$track\" \"$percentage\")\n\n    if [[ \"$CI_PROJECT_VISIBILITY\" != \"public\" ]]; then\n      secret_name='gitlab-registry'\n    else\n      secret_name=''\n    fi\n\n    create_application_secret \"$track\"\n\n    env_slug=$(echo ${CI_ENVIRONMENT_SLUG//-/_} | tr -s '[:lower:]' '[:upper:]')\n    eval env_ADDITIONAL_HOSTS=\\$${env_slug}_ADDITIONAL_HOSTS\n    if [ -n \"$env_ADDITIONAL_HOSTS\" ]; then\n      additional_hosts=\"{$env_ADDITIONAL_HOSTS}\"\n    elif [ -n \"$ADDITIONAL_HOSTS\" ]; then\n      additional_hosts=\"{$ADDITIONAL_HOSTS}\"\n    fi\n\n    if [[ -n \"$DB_INITIALIZE\" \u0026\u0026 -z \"$(helm ls -q \"^$name$\")\" ]]; then\n      echo \"Deploying first release with database initialization...\"\n      helm upgrade --install \\\n        --wait \\\n        --set service.enabled=\"$service_enabled\" \\\n        --set releaseOverride=\"$CI_ENVIRONMENT_SLUG\" \\\n        --set image.repository=\"$CI_APPLICATION_REPOSITORY\" \\\n        --set image.tag=\"$CI_APPLICATION_TAG\" \\\n        --set image.pullPolicy=IfNotPresent \\\n        --set image.secrets[0].name=\"$secret_name\" \\\n        --set application.track=\"$track\" \\\n        --set application.database_url=\"$DATABASE_URL\" \\\n        --set application.secretName=\"$APPLICATION_SECRET_NAME\" \\\n        --set application.secretChecksum=\"$APPLICATION_SECRET_CHECKSUM\" \\\n        --set service.commonName=\"le.$KUBE_INGRESS_BASE_DOMAIN\" \\\n        --set service.url=\"$CI_ENVIRONMENT_URL\" \\\n        --set service.additionalHosts=\"$additional_hosts\" \\\n        --set replicaCount=\"$replicas\" \\\n        --set postgresql.enabled=\"$postgres_enabled\" \\\n        --set postgresql.nameOverride=\"postgres\" \\\n        --set postgresql.postgresUser=\"$POSTGRES_USER\" \\\n        --set postgresql.postgresPassword=\"$POSTGRES_PASSWORD\" \\\n        --set postgresql.postgresDatabase=\"$POSTGRES_DB\" \\\n        --set postgresql.imageTag=\"$POSTGRES_VERSION\" \\\n        --set application.initializeCommand=\"$DB_INITIALIZE\" \\\n        --namespace=\"$KUBE_NAMESPACE\" \\\n        \"$name\" \\\n        chart/\n\n      echo \"Deploying second release...\"\n      helm upgrade --reuse-values \\\n        --wait \\\n        --set application.initializeCommand=\"\" \\\n        --set application.migrateCommand=\"$DB_MIGRATE\" \\\n        --namespace=\"$KUBE_NAMESPACE\" \\\n        \"$name\" \\\n        chart/\n    else\n      echo \"Deploying new release...\"\n      helm upgrade --install \\\n        --wait \\\n        --set service.enabled=\"$service_enabled\" \\\n        --set releaseOverride=\"$CI_ENVIRONMENT_SLUG\" \\\n        --set image.repository=\"$CI_APPLICATION_REPOSITORY\" \\\n        --set image.tag=\"$CI_APPLICATION_TAG\" \\\n        --set image.pullPolicy=IfNotPresent \\\n        --set image.secrets[0].name=\"$secret_name\" \\\n        --set application.track=\"$track\" \\\n        --set application.database_url=\"$DATABASE_URL\" \\\n        --set application.secretName=\"$APPLICATION_SECRET_NAME\" \\\n        --set application.secretChecksum=\"$APPLICATION_SECRET_CHECKSUM\" \\\n        --set service.commonName=\"le.$KUBE_INGRESS_BASE_DOMAIN\" \\\n        --set service.url=\"$CI_ENVIRONMENT_URL\" \\\n        --set service.additionalHosts=\"$additional_hosts\" \\\n        --set replicaCount=\"$replicas\" \\\n        --set postgresql.enabled=\"$postgres_enabled\" \\\n        --set postgresql.nameOverride=\"postgres\" \\\n        --set postgresql.postgresUser=\"$POSTGRES_USER\" \\\n        --set postgresql.postgresPassword=\"$POSTGRES_PASSWORD\" \\\n        --set postgresql.postgresDatabase=\"$POSTGRES_DB\" \\\n        --set application.migrateCommand=\"$DB_MIGRATE\" \\\n        --namespace=\"$KUBE_NAMESPACE\" \\\n        \"$name\" \\\n        chart/\n    fi\n\n    kubectl rollout status -n \"$KUBE_NAMESPACE\" -w \"$ROLLOUT_RESOURCE_TYPE/$name\"\n  }\n\n  function scale() {\n    track=\"${1-stable}\"\n    percentage=\"${2-100}\"\n    name=$(deploy_name \"$track\")\n\n    replicas=$(get_replicas \"$track\" \"$percentage\")\n\n    if [[ -n \"$(helm ls -q \"^$name$\")\" ]]; then\n      helm upgrade --reuse-values \\\n        --wait \\\n        --set replicaCount=\"$replicas\" \\\n        --namespace=\"$KUBE_NAMESPACE\" \\\n        \"$name\" \\\n        chart/\n    fi\n  }\n\n  function install_dependencies() {\n    apk add -U openssl curl tar gzip bash ca-certificates git\n    curl -L -o /etc/apk/keys/sgerrand.rsa.pub https://alpine-pkgs.sgerrand.com/sgerrand.rsa.pub\n    curl -L -O https://github.com/sgerrand/alpine-pkg-glibc/releases/download/2.28-r0/glibc-2.28-r0.apk\n    apk add glibc-2.28-r0.apk\n    rm glibc-2.28-r0.apk\n\n    curl \"https://kubernetes-helm.storage.googleapis.com/helm-v${HELM_VERSION}-linux-amd64.tar.gz\" | tar zx\n    mv linux-amd64/helm /usr/bin/\n    mv linux-amd64/tiller /usr/bin/\n    helm version --client\n    tiller -version\n\n    curl -L -o /usr/bin/kubectl \"https://storage.googleapis.com/kubernetes-release/release/v${KUBERNETES_VERSION}/bin/linux/amd64/kubectl\"\n    chmod +x /usr/bin/kubectl\n    kubectl version --client\n  }\n\n  function setup_docker() {\n    if ! docker info \u0026\u003e/dev/null; then\n      if [ -z \"$DOCKER_HOST\" -a \"$KUBERNETES_PORT\" ]; then\n        export DOCKER_HOST='tcp://localhost:2375'\n      fi\n    fi\n  }\n\n  function setup_test_db() {\n    if [ -z ${KUBERNETES_PORT+x} ]; then\n      DB_HOST=postgres\n    else\n      DB_HOST=localhost\n    fi\n    export DATABASE_URL=\"postgres://${POSTGRES_USER}:${POSTGRES_PASSWORD}@${DB_HOST}:5432/${POSTGRES_DB}\"\n  }\n\n  function download_chart() {\n    if [[ ! -d chart ]]; then\n      auto_chart=${AUTO_DEVOPS_CHART:-gitlab/auto-deploy-app}\n      auto_chart_name=$(basename $auto_chart)\n      auto_chart_name=${auto_chart_name%.tgz}\n      auto_chart_name=${auto_chart_name%.tar.gz}\n    else\n      auto_chart=\"chart\"\n      auto_chart_name=\"chart\"\n    fi\n\n    helm init --client-only\n    helm repo add gitlab ${AUTO_DEVOPS_CHART_REPOSITORY:-https://charts.gitlab.io}\n    if [[ ! -d \"$auto_chart\" ]]; then\n      helm fetch ${auto_chart} --untar\n    fi\n    if [ \"$auto_chart_name\" != \"chart\" ]; then\n      mv ${auto_chart_name} chart\n    fi\n\n    helm dependency update chart/\n    helm dependency build chart/\n  }\n\n  function ensure_namespace() {\n    kubectl describe namespace \"$KUBE_NAMESPACE\" || kubectl create namespace \"$KUBE_NAMESPACE\"\n  }\n\n\n  # Function to ensure backwards compatibility with AUTO_DEVOPS_DOMAIN\n  function ensure_kube_ingress_base_domain() {\n    if [ -z ${KUBE_INGRESS_BASE_DOMAIN+x} ] \u0026\u0026 [ -n \"$AUTO_DEVOPS_DOMAIN\" ] ; then\n      export KUBE_INGRESS_BASE_DOMAIN=$AUTO_DEVOPS_DOMAIN\n    fi\n  }\n\n  function check_kube_domain() {\n    ensure_kube_ingress_base_domain\n\n    if [ -z ${KUBE_INGRESS_BASE_DOMAIN+x} ]; then\n      echo \"In order to deploy or use Review Apps,\"\n      echo \"AUTO_DEVOPS_DOMAIN or KUBE_INGRESS_BASE_DOMAIN variables must be set\"\n      echo \"From 11.8, you can set KUBE_INGRESS_BASE_DOMAIN in cluster settings\"\n      echo \"or by defining a variable at group or project level.\"\n      echo \"You can also manually add it in .gitlab-ci.yml\"\n      echo \"AUTO_DEVOPS_DOMAIN support will be dropped on 12.0\"\n      false\n    else\n      true\n    fi\n  }\n\n  function initialize_tiller() {\n    echo \"Checking Tiller...\"\n\n    export HELM_HOST=\"localhost:44134\"\n    tiller -listen ${HELM_HOST} -alsologtostderr \u003e /dev/null 2\u003e\u00261 \u0026\n    echo \"Tiller is listening on ${HELM_HOST}\"\n\n    if ! helm version --debug; then\n      echo \"Failed to init Tiller.\"\n      return 1\n    fi\n    echo \"\"\n  }\n\n  function create_secret() {\n    echo \"Create secret...\"\n    if [[ \"$CI_PROJECT_VISIBILITY\" == \"public\" ]]; then\n      return\n    fi\n\n    kubectl create secret -n \"$KUBE_NAMESPACE\" \\\n      docker-registry gitlab-registry \\\n      --docker-server=\"$CI_REGISTRY\" \\\n      --docker-username=\"${CI_DEPLOY_USER:-$CI_REGISTRY_USER}\" \\\n      --docker-password=\"${CI_DEPLOY_PASSWORD:-$CI_REGISTRY_PASSWORD}\" \\\n      --docker-email=\"$GITLAB_USER_EMAIL\" \\\n      -o yaml --dry-run | kubectl replace -n \"$KUBE_NAMESPACE\" --force -f -\n  }\n\n  function dast() {\n    export CI_ENVIRONMENT_URL=$(cat environment_url.txt)\n\n    mkdir /zap/wrk/\n    /zap/zap-baseline.py -J gl-dast-report.json -t \"$CI_ENVIRONMENT_URL\" || true\n    cp /zap/wrk/gl-dast-report.json .\n  }\n\n  function performance() {\n    export CI_ENVIRONMENT_URL=$(cat environment_url.txt)\n\n    mkdir gitlab-exporter\n    wget -O gitlab-exporter/index.js https://gitlab.com/gitlab-org/gl-performance/raw/10-5/index.js\n\n    mkdir sitespeed-results\n\n    if [ -f .gitlab-urls.txt ]\n    then\n      sed -i -e 's@^@'\"$CI_ENVIRONMENT_URL\"'@' .gitlab-urls.txt\n      docker run --shm-size=1g --rm -v \"$(pwd)\":/sitespeed.io sitespeedio/sitespeed.io:6.3.1 --plugins.add ./gitlab-exporter --outputFolder sitespeed-results .gitlab-urls.txt\n    else\n      docker run --shm-size=1g --rm -v \"$(pwd)\":/sitespeed.io sitespeedio/sitespeed.io:6.3.1 --plugins.add ./gitlab-exporter --outputFolder sitespeed-results \"$CI_ENVIRONMENT_URL\"\n    fi\n\n    mv sitespeed-results/data/performance.json performance.json\n  }\n\n  function persist_environment_url() {\n      echo $CI_ENVIRONMENT_URL \u003e environment_url.txt\n  }\n\n  function delete() {\n    track=\"${1-stable}\"\n    name=$(deploy_name \"$track\")\n\n    if [[ -n \"$(helm ls -q \"^$name$\")\" ]]; then\n      helm delete --purge \"$name\"\n    fi\n\n    secret_name=$(application_secret_name \"$track\")\n    kubectl delete secret --ignore-not-found -n \"$KUBE_NAMESPACE\" \"$secret_name\"\n  }\n\nbefore_script:\n  - *auto_devops\n"}